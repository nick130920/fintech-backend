---
description: Reglas de diseÃ±o y desarrollo para Fintech Backend
globs:
alwaysApply: true
---

# Fintech Backend - Reglas de Desarrollo

## ğŸ—ï¸ Arquitectura y Estructura

### Clean Architecture
- Mantener separaciÃ³n clara entre capas: handlers, use cases, entities, repositories
- No mezclar lÃ³gica de negocio con detalles de implementaciÃ³n
- Dependencias deben apuntar hacia el centro (domain)

### Estructura de Directorios
```
internal/
â”œâ”€â”€ controller/http/v1/     # Handlers HTTP
â”œâ”€â”€ usecase/               # LÃ³gica de negocio
â”œâ”€â”€ entity/                # Entidades de dominio
â”œâ”€â”€ repository/            # Implementaciones de repositorio
â””â”€â”€ app/                   # ConfiguraciÃ³n de la aplicaciÃ³n
```

## ğŸ“ EstÃ¡ndares de CÃ³digo

### Nomenclatura
- **Handlers**: Terminar con `Handler` (ej: `ExpenseHandler`)
- **Use Cases**: Usar verbos descriptivos (ej: `CreateExpense`, `GetUserBudget`)
- **Entities**: Nombres singulares (ej: `User`, `Expense`, `Budget`)
- **DTOs**: Terminar con el propÃ³sito (ej: `CreateExpenseRequest`, `ExpenseResponse`)

### Manejo de Errores
```go
// âœ… CORRECTO: Errores descriptivos
if err != nil {
    return nil, fmt.Errorf("failed to create expense: %w", err)
}

// âœ… CORRECTO: Errores de dominio
var ErrExpenseNotFound = errors.New("expense not found")

// âŒ INCORRECTO: Errores genÃ©ricos
if err != nil {
    return nil, err
}
```

### ValidaciÃ³n de Datos
```go
// âœ… CORRECTO: Validar en el handler
func (h *ExpenseHandler) CreateExpense(c *gin.Context) {
    var req dto.CreateExpenseRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "invalid request"})
        return
    }
    
    if err := h.validator.Validate(req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
}
```

## ğŸ”’ Seguridad y AutenticaciÃ³n

### JWT y Middleware
- Siempre validar tokens JWT en endpoints protegidos
- Extraer user ID del contexto autenticado
- No exponer informaciÃ³n sensible en logs

```go
// âœ… CORRECTO: Obtener user ID del contexto
userID, exists := c.Get("user_id")
if !exists {
    c.JSON(401, gin.H{"error": "unauthorized"})
    return
}
```

### ValidaciÃ³n de Permisos
- Verificar que el usuario tiene acceso a los recursos solicitados
- Validar ownership de datos antes de operaciones CRUD

## ğŸ’¾ Base de Datos

### Transacciones
```go
// âœ… CORRECTO: Usar transacciones para operaciones complejas
tx := r.db.Begin()
defer func() {
    if r := recover(); r != nil {
        tx.Rollback()
    }
}()

if err := tx.Create(&expense).Error; err != nil {
    tx.Rollback()
    return err
}

if err := tx.Create(&budgetUpdate).Error; err != nil {
    tx.Rollback()
    return err
}

return tx.Commit().Error
```

### Migraciones
- Siempre crear migraciones para cambios de esquema
- Nombrar migraciones con timestamp y descripciÃ³n clara
- Incluir rollback en todas las migraciones

## ğŸ“Š DTOs y Responses

### Estructura Consistente
```go
// âœ… CORRECTO: Response estructurado
type ExpenseResponse struct {
    ID          uint      `json:"id"`
    Amount      float64   `json:"amount"`
    Description string    `json:"description"`
    CategoryID  uint      `json:"category_id"`
    Category    Category  `json:"category"`
    CreatedAt   time.Time `json:"created_at"`
}

// âœ… CORRECTO: Request con validaciones
type CreateExpenseRequest struct {
    Amount      float64 `json:"amount" validate:"required,gt=0"`
    Description string  `json:"description" validate:"required"`
    CategoryID  uint    `json:"category_id" validate:"required"`
}
```

### PaginaciÃ³n EstÃ¡ndar
```go
type PaginatedResponse struct {
    Data       interface{} `json:"data"`
    Total      int64      `json:"total"`
    Page       int        `json:"page"`
    PerPage    int        `json:"per_page"`
    TotalPages int        `json:"total_pages"`
}
```

## ğŸ§ª Testing

### Estructura de Tests
```go
func TestExpenseHandler_CreateExpense(t *testing.T) {
    tests := []struct {
        name           string
        request        dto.CreateExpenseRequest
        expectedStatus int
        expectedError  string
    }{
        {
            name: "valid expense creation",
            request: dto.CreateExpenseRequest{
                Amount:      100.0,
                Description: "Test expense",
                CategoryID:  1,
            },
            expectedStatus: 201,
        },
        // ... mÃ¡s casos
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### Mocks y Dependencias
- Usar interfaces para todas las dependencias
- Crear mocks para testing unitario
- Tests de integraciÃ³n para endpoints completos

## ğŸ“¡ API Design

### RESTful Endpoints
```
GET    /api/v1/expenses              # Listar gastos
POST   /api/v1/expenses              # Crear gasto
GET    /api/v1/expenses/:id          # Obtener gasto especÃ­fico
PUT    /api/v1/expenses/:id          # Actualizar gasto
DELETE /api/v1/expenses/:id          # Eliminar gasto
```

### Status Codes EstÃ¡ndar
- `200` - OK (GET, PUT exitosos)
- `201` - Created (POST exitoso)
- `204` - No Content (DELETE exitoso)
- `400` - Bad Request (validaciÃ³n fallÃ³)
- `401` - Unauthorized (no autenticado)
- `403` - Forbidden (no autorizado)
- `404` - Not Found (recurso no existe)
- `500` - Internal Server Error

### Headers de Response
```go
// âœ… CORRECTO: Headers consistentes
c.Header("Content-Type", "application/json")
c.Header("X-API-Version", "v1")
```

## ğŸ” Logging y Monitoring

### Structured Logging
```go
// âœ… CORRECTO: Logs estructurados
log.WithFields(log.Fields{
    "user_id":    userID,
    "expense_id": expenseID,
    "amount":     amount,
}).Info("expense created successfully")

// âŒ INCORRECTO: Logs no estructurados
log.Printf("User %d created expense %d with amount %f", userID, expenseID, amount)
```

### MÃ©tricas
- Instrumentar endpoints crÃ­ticos
- Medir latencia de operaciones de base de datos
- Trackear errores por tipo

## ğŸš€ Performance

### Database Queries
```go
// âœ… CORRECTO: Preload relaciones necesarias
var expenses []entity.Expense
err := r.db.Preload("Category").Where("user_id = ?", userID).Find(&expenses).Error

// âŒ INCORRECTO: N+1 queries
for _, expense := range expenses {
    r.db.First(&expense.Category, expense.CategoryID)
}
```

### Caching
- Implementar cache para datos frecuentemente accedidos
- Cache de categorÃ­as, configuraciones de usuario
- TTL apropiado para cada tipo de data

## ğŸ”§ ConfiguraciÃ³n

### Environment Variables
```go
// âœ… CORRECTO: ConfiguraciÃ³n centralizada
type Config struct {
    Port       string `env:"PORT" envDefault:"8080"`
    DBHost     string `env:"DB_HOST" envDefault:"localhost"`
    DBPort     string `env:"DB_PORT" envDefault:"5432"`
    JWTSecret  string `env:"JWT_SECRET,required"`
}
```

### Secrets Management
- Nunca hardcodear secrets en cÃ³digo
- Usar variables de entorno para configuraciÃ³n sensible
- Rotar secrets regularmente

## ğŸ“š DocumentaciÃ³n

### Swagger/OpenAPI
- Documentar todos los endpoints
- Incluir ejemplos de request/response
- Mantener documentaciÃ³n actualizada con el cÃ³digo

### Comments
```go
// CreateExpense handles the creation of a new expense for the authenticated user.
// It validates the request, checks budget limits, and persists the expense.
//
// @Summary Create a new expense
// @Tags expenses
// @Accept json
// @Produce json
// @Param expense body dto.CreateExpenseRequest true "Expense data"
// @Success 201 {object} dto.ExpenseResponse
// @Failure 400 {object} dto.ErrorResponse
// @Router /expenses [post]
func (h *ExpenseHandler) CreateExpense(c *gin.Context) {
    // Implementation
}
```

## ğŸ”„ Migration y Deployment

### Database Migrations
- Versionar todas las migraciones
- Incluir rollback para cada migraciÃ³n
- Testar migraciones en staging antes de production

### Deployment
- Zero-downtime deployments
- Health checks configurados
- Rollback automÃ¡tico en caso de fallos

## âš¡ Quick Reference

### Checklist Pre-Commit
- [ ] Tests pasan (unit + integration)
- [ ] Linting sin errores (`golangci-lint`)
- [ ] DocumentaciÃ³n actualizada
- [ ] Migraciones incluidas si es necesario
- [ ] Logs estructurados agregados
- [ ] Validaciones de entrada implementadas
- [ ] Manejo de errores apropiado
- [ ] No hay secrets hardcodeados

### Comandos Ãštiles
```bash
# Testing
go test ./... -cover

# Linting
golangci-lint run

# Build
go build -o bin/fintech-backend cmd/server/main.go

# Migration
migrate -path migrations -database "postgres://..." up
```

---

**Recordatorio**: Estas reglas aseguran cÃ³digo mantenible, seguro y escalable para la aplicaciÃ³n fintech. La consistencia es clave para el trabajo en equipo y la calidad del producto.
